<!doctype html>
<html lang=en>
   <head>
      <meta charset=utf-8>
      <meta name=viewport content="width=device-width, initial-scale=1, maximum-scale=1">
      <title>API Reference</title>
      <link rel=icon href=images/bookmark.png>
      <link href=stylesheets/screen.css rel=stylesheet media=screen>
      <link href=stylesheets/print.css rel=stylesheet media=print>
      <link href=stylesheets/highlight-monokai.css rel=stylesheet media=screen,print>
      <script src=javascripts/all.js></script>
   </head>
   <body class="" data-languages="[&#34;json&#34;,&#34;plaintext&#34;,&#34;python&#34;]">
      <a href=# id=nav-button>
         <span>NAV <img alt=navbar class=image-navbar src=images/navbar.png></span>
      </a>
      <div class=tocify-wrapper>
         <img alt=logo class=image-logo src=images/logo.png>
         <div class=lang-selector>
            <a href=# data-language-name="json">json</a>
            <a href=# data-language-name="plaintext">plaintext</a>
            <a href=# data-language-name="python">python</a>
         </div>
         <div class=search>
            <input type=text class=search id=input-search placeholder="Search">
         </div>
         <ul class=search-results></ul>
         <div id=toc></div>
         <ul class=toc-footer>
            <li><a href=https://github.com/center-key/node-slate>node-slate on GitHub</a></li>
            <li><a href=https://www.npmjs.com/package/node-slate>Documentation powered by Slate</a></li>
         </ul>
      </div>
      <div class=page-wrapper>
         <div class=dark-box></div>
         <div class=content>
            <h1 id="derivadex-api">DerivaDEX API</h1>
            <p>DerivaDEX is a decentralized derivatives exchange that combines the performance of centralized exchanges with the security of decentralized exchanges.</p>
            <p>DerivaDEX currently offers a public WebSocket API for traders and developers. In order to use this API, you must must first make a deposit to the DerivaDEX Ethereum contracts. The API will then enable you to open and manage your positions via commands, and subscribe to market data via <code>subscriptions</code>. </p>
            <p>Find us online <a href="https://discord.gg/a54BWuG">Discord</a> | <a href="https://t.me/DerivaDEX">Telegram</a> | <a href="https://medium.com/derivadex">Medium</a></p>
            <h1 id="getting-started">Getting started</h1>
            <p>To begin interacting with the DerivaDEX ecosystem programmatically, you generally will want to follow these steps:</p>
            <ol>
               <li>Deposit funds via Ethereum via an Ethereum client</li>
               <li>Authenticate and connect to the websocket API</li>
               <li>Submit and cancel orders via <code>commands</code></li>
               <li>Subscribe to market and account data feeds via <code>subscriptions</code></li>
            </ol>
            <p>Additionally, you should familiarize yourself with the <a href="#Types">DerivaDEX types terminology</a> and [hashing &amp; signing schemes](#Signatures &amp; hashing). </p>
            <h2 id="types">Types</h2>
            <p>The types labeled throughout this document in the request and response parameters may be familiar to those who have a background in Ethereum. In any case, please refer to the table below for additional information on the terminology used here. This reference in conjunction with the JSON samples should provide enough clarity:</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>description</th>
                     <th>example</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>string</td>
                     <td>Literal of a sequence of characters surrounded by quotes</td>
                     <td>&quot;ETHPERP&quot;</td>
                  </tr>
                  <tr>
                     <td>address_s</td>
                     <td>20-byte &quot;0x&quot;-prefixed hexadecimal string literal (i.e. 40 digits long) corresponding to an <code>address</code> ETH type</td>
                     <td>&quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;</td>
                  </tr>
                  <tr>
                     <td>decimal</td>
                     <td>Numerical value with up to, but no more than 18 decimals of precision</td>
                     <td>10.031500000000000000</td>
                  </tr>
                  <tr>
                     <td>decimal_s</td>
                     <td>String representation of <code>decimal</code></td>
                     <td>&quot;10.031500000000000000&quot;</td>
                  </tr>
                  <tr>
                     <td>bool</td>
                     <td>Boolean value, either <code>true</code> or <code>false</code></td>
                     <td>True</td>
                  </tr>
                  <tr>
                     <td>bytes32_s</td>
                     <td>32-byte &quot;0x&quot;-prefixed hexadecimal string literal (i.e. 64 digits long) corresponding to an <code>bytes32</code> ETH type</td>
                     <td>&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</td>
                  </tr>
                  <tr>
                     <td>timestamp_s_i</td>
                     <td>String representation of numerical UNIX timestamp representing the number of seconds since 1/1/1970</td>
                     <td>&quot;1616667513875&quot;</td>
                  </tr>
                  <tr>
                     <td>timestamp_s</td>
                     <td>String representation representing the ISO 8601 UTC timestamp</td>
                     <td>&quot;2021-03-25T10:38:09.503654+00:00&quot;</td>
                  </tr>
               </tbody>
            </table>
            <h2 id="signatures--hashing">Signatures &amp; hashing</h2>
            <p>All <a href="#Commands"><code>commands</code></a> on the API must be signed. The payload you will sign using an Ethereum wallet client of your choice (e.g. ethers, web3.js, web3.py, etc.) will need to be hashed as per the EIP-712 standard. We <strong>highly recommend</strong> referring to the <a href="https://eips.ethereum.org/EIPS/eip-712">original proposal</a> for full context, but in short, this standard introduced a framework by which users can securely sign typed structured data. This greatly improves the crypto UX as users can now sign data they see and understand as opposed to unreadable byte-strings. While these benefits may not be readily apparent for programmatic traders, you will need to conform to this standard regardless.</p>
            <p>EIP-712 hashing consists of three critical components - a <code>header</code>, <code>domain</code> struct hash, and <code>message</code> struct hash.</p>
            <h3 id="header">Header</h3>
            <blockquote>
               <p>Sample EIP-191 header definition</p>
            </blockquote>
            <pre class="highlight plaintext"><code>// solidity
bytes2 eip191_header = 0x1901;</code></pre><pre class="highlight python"><code>eip191_header = <span class="hljs-string">b&quot;\x19\x01&quot;</span></code></pre>
            <p>The <code>header</code> is simply the byte-string <code>\x19\x01</code>. You are welcome to do this however you like, but it must adhere to the standard eventually, otherwise the signature will not ultimately successfully recover. Example Solidity and Python reference implementations are displayed on the right, but feel free to utilize whichever language, tooling, and abstractions you see fit.</p>
            <h3 id="domain">Domain</h3>
            <blockquote>
               <p>Domain separator for mainnet. DO NOT modify these parameters.</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;DerivaDEX&quot;</span>,
    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,
    <span class="hljs-attr">&quot;chainId&quot;</span>:  <span class="hljs-number">1</span>,
    <span class="hljs-attr">&quot;verifyingContract&quot;</span>: <span class="hljs-string">&quot;0x&quot;</span>
}</code></pre>
            <blockquote>
               <p>Sample computation of domain struct hash</p>
            </blockquote>
            <pre class="highlight plaintext"><code>// solidity
function compute_eip712_domain_struct_hash(string memory _name, string memory _version, uint256 _chainId, address _verifyingContract) public view returns (bytes32) {
    // keccak-256 hash of the encoded schema for the domain separator
    bytes32 domainSchemaHash = keccak256(abi.encodePacked(
        &quot;EIP712Domain(&quot;,
        &quot;string name,&quot;,
        &quot;string version,&quot;,
        &quot;uint256 chainId,&quot;,
        &quot;address verifyingContract&quot;,
        &quot;)&quot;
    ));
    
    bytes32 domainStructHash = keccak256(abi.encodePacked(
        domainSchemaHash,
        keccak256(bytes(_name)),
        keccak256(bytes(_version)),
        _chainId,
        uint256(_verifyingContract)
    ));
    
    return domainStructHash;
}</code></pre><pre class="highlight python"><code><span class="hljs-keyword">from</span> eth_abi <span class="hljs-keyword">import</span> encode_single
<span class="hljs-keyword">from</span> eth_utils.crypto <span class="hljs-keyword">import</span> keccak

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_eip712_domain_struct_hash</span>(<span class="hljs-params">chain_id</span>):</span>
    <span class="hljs-comment"># keccak-256 hash of the encoded schema for the domain separator</span>
    eip712_domain_separator_schema_hash = keccak(
        <span class="hljs-string">b&quot;EIP712Domain(&quot;</span>
        + <span class="hljs-string">b&quot;string name,&quot;</span>
        + <span class="hljs-string">b&quot;string version,&quot;</span>
        + <span class="hljs-string">b&quot;uint256 chainId,&quot;</span>
        + <span class="hljs-string">b&quot;address verifyingContract&quot;</span>
        + <span class="hljs-string">b&quot;)&quot;</span>
    )
    
    <span class="hljs-keyword">return</span> keccak(
        eip712_domain_separator_schema_hash
        + keccak(<span class="hljs-string">b&quot;DerivaDEX&quot;</span>)
        + keccak(<span class="hljs-string">b&quot;1&quot;</span>)
        + encode_single(<span class="hljs-string">&#x27;uint256&#x27;</span>, chain_id)
        + encode_single(<span class="hljs-string">&#x27;address&#x27;</span>, <span class="hljs-string">&quot;0x&quot;</span>)
    )</code></pre>
            <p>The <code>domain</code> is a mandatory field that allows for signature/hashing schemes on one dApp to be unique to itself from other dApps. All <code>commands</code> use the same <code>domain</code> specification. The parameters that comprise the domain are as follows:</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>name</td>
                     <td>string</td>
                     <td>Name of the dApp or protocol</td>
                  </tr>
                  <tr>
                     <td>version</td>
                     <td>string</td>
                     <td>Current version of the signing domain</td>
                  </tr>
                  <tr>
                     <td>chainId</td>
                     <td>uint256</td>
                     <td>EIP-155 chain ID</td>
                  </tr>
               </tbody>
            </table>
            <p>To generate the <code>domain</code> struct hash, you must perform a series of encodings and hashings of the schema and contents of the <code>domain</code> specfication. You are welcome to do this however you like, but it must adhere to the standard eventually, otherwise the signature will not ultimately successfully recover. Example Solidity and Python reference implementations are displayed on the right, but feel free to utilize whichever language, tooling, and abstractions you see fit.</p>
            <h3 id="message">Message</h3>
            <p>The <code>message</code> field varies depending on the typed data you are signing, and is illustrated on a case-by-case basis below.</p>
            <h3 id="place-order-message">Place order (message)</h3>
            <blockquote>
               <p>Sample computation of order struct hash</p>
            </blockquote>
            <pre class="highlight plaintext"><code>// solidity
function compute_eip712_order_struct_hash(address _traderAddress, bytes32 _symbol, bytes32 _strategy, uint256 _side, uint256 _orderType, bytes32 _requestId, uint256 _amount, uint256 _price, uint256 _stopPrice) public view returns (bytes32) {
    // keccak-256 hash of the encoded schema for the order params struct
    bytes32 orderSchemaHash = keccak256(abi.encodePacked(
        &quot;OrderParams(&quot;,
        &quot;address traderAddress,&quot;,
        &quot;bytes32 symbol,&quot;,
        &quot;bytes32 strategy,&quot;,
        &quot;uint256 side,&quot;,
        &quot;uint256 orderType,&quot;,
        &quot;bytes32 requestId,&quot;,
        &quot;uint256 amount,&quot;,
        &quot;uint256 price,&quot;,
        &quot;uint256 stopPrice&quot;,
        &quot;)&quot;
    ));
    
    bytes32 orderStructHash = keccak256(abi.encodePacked(
        orderSchemaHash,
        uint256(_traderAddress),
        _symbol,
        _strategy,
        _side,
        _orderType,
        _requestId,
        _amount,
        _price,
        _stopPrice
    ));
    
    return orderStructHash;
}</code></pre><pre class="highlight python"><code><span class="hljs-keyword">from</span> eth_abi <span class="hljs-keyword">import</span> encode_single
<span class="hljs-keyword">from</span> eth_utils.crypto <span class="hljs-keyword">import</span> keccak
<span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal, ROUND_DOWN

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_eip712_order_struct_hash</span>(<span class="hljs-params">trader_address: <span class="hljs-built_in">str</span>, symbol: <span class="hljs-built_in">str</span>, strategy: <span class="hljs-built_in">str</span>, side: <span class="hljs-built_in">str</span>, order_type: <span class="hljs-built_in">str</span>, request_id: <span class="hljs-built_in">str</span>, amount: Decimal, price: Decimal, stop_price: Decimal</span>) -&gt; bytes:</span>
    <span class="hljs-comment"># keccak-256 hash of the encoded schema for the place order command</span>
    eip712_order_params_schema_hash = keccak(
        <span class="hljs-string">b&quot;OrderParams(&quot;</span>
        + <span class="hljs-string">b&quot;address traderAddress,&quot;</span>
        + <span class="hljs-string">b&quot;bytes32 symbol,&quot;</span>
        + <span class="hljs-string">b&quot;bytes32 strategy,&quot;</span>
        + <span class="hljs-string">b&quot;uint256 side,&quot;</span>
        + <span class="hljs-string">b&quot;uint256 orderType,&quot;</span>
        + <span class="hljs-string">b&quot;bytes32 requestId,&quot;</span>
        + <span class="hljs-string">b&quot;uint256 amount,&quot;</span>
        + <span class="hljs-string">b&quot;uint256 price,&quot;</span>
        + <span class="hljs-string">b&quot;uint256 stopPrice&quot;</span>
        + <span class="hljs-string">b&quot;)&quot;</span>
    )
    
    <span class="hljs-comment"># Ensure decimal value has no more than 18 decimals of precision</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">round_to_unit</span>(<span class="hljs-params">val</span>):</span>
        <span class="hljs-keyword">return</span> val.quantize(Decimal(<span class="hljs-string">&quot;.000000000000000001&quot;</span>), rounding=ROUND_DOWN)
    
    <span class="hljs-comment"># Scale up to DDX grains format (i.e. multiply by 1e18)</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_base_unit_amount</span>(<span class="hljs-params">val, decimals</span>):</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(round_to_unit(val) * <span class="hljs-number">10</span> ** decimals)

    <span class="hljs-comment"># Convert order side string to int representation</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">order_side_to_int</span>(<span class="hljs-params">order_side: <span class="hljs-built_in">str</span></span>) -&gt; int:</span>
        <span class="hljs-keyword">if</span> order_side == <span class="hljs-string">&#x27;Bid&#x27;</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># Convert order type string to int representation</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">order_type_to_int</span>(<span class="hljs-params">order_type: <span class="hljs-built_in">str</span></span>) -&gt; int:</span>
        <span class="hljs-keyword">if</span> order_type == <span class="hljs-string">&#x27;Limit&#x27;</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">elif</span> order_type == <span class="hljs-string">&#x27;Market&#x27;</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>

    <span class="hljs-keyword">return</span> keccak(
        eip712_order_params_schema_hash
        + encode_single(<span class="hljs-string">&#x27;address&#x27;</span>, trader_address)
        + encode_single(<span class="hljs-string">&#x27;bytes32&#x27;</span>, symbol.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))
        + encode_single(<span class="hljs-string">&#x27;bytes32&#x27;</span>, strategy.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))
        + encode_single(<span class="hljs-string">&#x27;uint256&#x27;</span>, order_side_to_int(side))
        + encode_single(<span class="hljs-string">&#x27;uint256&#x27;</span>, order_type_to_int(order_type))
        + encode_single(<span class="hljs-string">&#x27;bytes32&#x27;</span>, <span class="hljs-built_in">bytes</span>.fromhex(request_id[<span class="hljs-number">2</span>:]))
        + encode_single(<span class="hljs-string">&#x27;uint256&#x27;</span>, to_base_unit_amount(amount, <span class="hljs-number">18</span>))
        + encode_single(<span class="hljs-string">&#x27;uint256&#x27;</span>, to_base_unit_amount(price, <span class="hljs-number">18</span>))
        + encode_single(<span class="hljs-string">&#x27;uint256&#x27;</span>, to_base_unit_amount(stop_price, <span class="hljs-number">18</span>))
    )</code></pre>
            <p>The parameters that comprise the <code>message</code> for the <code>command</code> to place an order are as follows:</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>traderAddress</td>
                     <td>address</td>
                     <td>Trader&#39;s ETH address used to sign order intent</td>
                  </tr>
                  <tr>
                     <td>symbol</td>
                     <td>bytes32</td>
                     <td>32-byte encoding of the symbol this order is for. The <code>symbol</code> of the order you send to the API is a string, however for signing purposes, you must bytes-encode and pad accordingly.</td>
                  </tr>
                  <tr>
                     <td>strategy</td>
                     <td>bytes32</td>
                     <td>32-byte encoding of the strategy this order belongs to. The <code>strategy</code> of the order you send to the API is a string, however for signing purposes, you must bytes-encode and pad accordingly. The <code>strategy</code> refers to the cross-margined bucket this trade belongs to. Currently, there is only the default <code>main</code> strategy, but support for multiple strategies is coming soon!</td>
                  </tr>
                  <tr>
                     <td>side</td>
                     <td>uint256</td>
                     <td>An integer value either <code>0</code> (Bid) or <code>1</code> (Ask)</td>
                  </tr>
                  <tr>
                     <td>orderType</td>
                     <td>uint256</td>
                     <td>An integer value either <code>0</code> (Limit) or <code>1</code> (Market)</td>
                  </tr>
                  <tr>
                     <td>requestId</td>
                     <td>bytes32</td>
                     <td>32-byte nonce (an incrementing numeric identifier that is unique per user for all time) resulting in uniqueness of order</td>
                  </tr>
                  <tr>
                     <td>amount</td>
                     <td>uint256</td>
                     <td>Order amount (scaled up by 18 decimals; e.g. 2.5 =&gt; 2500000000000000000). The <code>amount</code> of the order you send to the API is a decimal, however for signing purposes, you must scale up by 18 decimals and convert to an integer.</td>
                  </tr>
                  <tr>
                     <td>price</td>
                     <td>uint256</td>
                     <td>Order price (scaled up by 18 decimals; e.g. 2001.37 =&gt; 2001370000000000000000). The <code>price</code> of the order you send to the API is a decimal, however for signing purposes, you must scale up by 18 decimals and convert to an integer.</td>
                  </tr>
                  <tr>
                     <td>stopPrice</td>
                     <td>uint256</td>
                     <td>Stop price (scaled up by 18 decimals). The <code>stopPrice</code> of the order you send to the API is a decimal, however for signing purposes, you must scale up by 18 decimals and convert to an integer.</td>
                  </tr>
               </tbody>
            </table>
            <p><strong>Take special note of the transformations done on several fields as described in the table above. In other words, the order intent you submit to the API will have different representations for some fields than the order intent you hash.</strong> You are welcome to do this however you like, but it must adhere to the standard eventually, otherwise the signature will not ultimately successfully recover. Example Solidity and Python reference implementations are displayed on the right, but feel free to utilize whichever language, tooling, and abstractions you see fit.</p>
            <h3 id="tying-it-all-together">Tying it all together</h3>
            <blockquote>
               <p>Computing the final EIP-712 hash</p>
            </blockquote>
            <pre class="highlight plaintext"><code>function compute_eip712_hash(bytes2 _eip191_header, bytes32 _domainStructHash, bytes32 _orderStructHash) public view returns (bytes32) {
    return keccak256(abi.encodePacked(
        _eip191_header,
        _domainStructHash,
        _orderStructHash
    ));
}</code></pre><pre class="highlight python"><code><span class="hljs-keyword">from</span> eth_utils.crypto <span class="hljs-keyword">import</span> keccak

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_eip712_hash</span>(<span class="hljs-params">eip191_header: <span class="hljs-built_in">bytes</span>, eip712_domain_struct_hash: <span class="hljs-built_in">bytes</span>, eip712_message_struct_hash: <span class="hljs-built_in">bytes</span></span>) -&gt; str:</span>
    <span class="hljs-comment"># Converting bytes result to a hexadecimal string</span>
    <span class="hljs-keyword">return</span> keccak(
        eip191_header
        + eip712_domain_struct_hash
        + eip712_message_struct_hash
    ).<span class="hljs-built_in">hex</span>()</code></pre>
            <p>To derive the final EIP-712 hash of the typed data you will sign, you will need to <code>keccak256</code> hash the <code>header</code>, <code>eip712_domain_struct_hash</code>, and <code>eip712_message_struct_hash</code> (will vary depending on which <code>command</code> specifically you are sending). You are welcome to do this however you like, but it must adhere to the standard eventually, otherwise the signature will not ultimately successfully recover. Example Solidity and Python reference implementations are displayed on the right, but feel free to utilize whichever language, tooling, and abstractions you see fit.</p>
            <h2 id="making-a-deposit">Making a deposit</h2>
            <blockquote>
               <p>Deposit ABI (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;inputs&quot;</span>: [
        {
            <span class="hljs-attr">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;address&quot;</span>,
            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;_collateralAddress&quot;</span>,
            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;address&quot;</span>
        },
        {
            <span class="hljs-attr">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;bytes32&quot;</span>,
            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;_strategyId&quot;</span>,
            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;bytes32&quot;</span>
        },
        {
            <span class="hljs-attr">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;uint128&quot;</span>,
            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;_amount&quot;</span>,
            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint128&quot;</span>
        }
    ],
    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;deposit&quot;</span>,
    <span class="hljs-attr">&quot;outputs&quot;</span>: [],
    <span class="hljs-attr">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;nonpayable&quot;</span>,
    <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span>
}</code></pre>
            <blockquote>
               <p>Smart contract deposit function (Solidity)</p>
            </blockquote>
            <pre class="highlight plaintext"><code>function deposit(
    address _collateralAddress,
    bytes32 _strategyId,
    uint128 _amount
) external;</code></pre>
            <blockquote>
               <p>Sample API URL connection generation (Python)</p>
            </blockquote>
            <pre class="highlight python"><code><span class="hljs-keyword">from</span> web3 <span class="hljs-keyword">import</span> Web3
<span class="hljs-keyword">from</span> eth_abi <span class="hljs-keyword">import</span> encode_single
<span class="hljs-keyword">import</span> simplejson <span class="hljs-keyword">as</span> json

<span class="hljs-comment"># A Web3 instance</span>
w3 = Web3(Web3.HTTPProvider(<span class="hljs-string">&quot;https://kovan.infura.io/v3/&lt;your_api_key&gt;&quot;</span>))

<span class="hljs-comment"># Open up the ABI shown above saved at a file location, in this case `trader_abi.json` is the filename</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;trader_abi.json&#x27;</span>) <span class="hljs-keyword">as</span> f:
    trader_abi = json.load(f)
    
    <span class="hljs-comment"># Create an trader_abi contract wrapper</span>
    trader_contract = w3.eth.contract(address=Web3.toChecksumAddress(<span class="hljs-string">&#x27;&lt;derivadex_contract_address&gt;&#x27;</span>), abi=trader_abi)
    
    <span class="hljs-comment"># Deposit 1000 USDC</span>
    trader_contract.functions.deposit(<span class="hljs-string">&#x27;&lt;usdc_address&gt;&#x27;</span>, encode_single(<span class="hljs-string">&quot;bytes32&quot;</span>, <span class="hljs-string">&#x27;main&#x27;</span>.encode(<span class="hljs-string">&quot;utf8&quot;</span>)), <span class="hljs-number">1000000000</span>).transact()</code></pre>
            <p>DerivaDEX is a decentralized exchange. As such, trading is non-custodial. Users are responsible for their own funds, which are deposited to the DerivaDEX smart contracts on Ethereum for trading. </p>
            <p>To deposit funds on DerivaDEX, first ensure that you have created an Ethereum account. The deposit interaction is between a user and the DerivaDEX smart contracts. To be more explicit, you will not be utilizing the WebSocket API to facilitate a deposit. The DerivaDEX Solidity smart contracts adhere to the <a href="https://medium.com/derivadex/the-diamond-standard-a-new-paradigm-for-upgradeability-569121a08954">Diamond Standard</a>. The <code>deposit</code> smart contract function you will need to use is located in the <code>Trader</code> facet, at the address of the main <code>DerivaDEX</code> proxy contract (insert address here).</p>
            <p>Note: Valid deposit collateral is curated by the smart contract and is managed by governance.</p>
            <table>
               <thead>
                  <tr>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>_collateralAddress</td>
                     <td>ERC-20 token address deposited as collateral</td>
                  </tr>
                  <tr>
                     <td>_strategyId</td>
                     <td>Strategy ID (encoded as a 32-byte value) being funded. The <code>strategy</code> refers to the cross-margined bucket this trade belongs to. Currently, there is only the default <code>main</code> strategy, but support for multiple strategies is coming soon!</td>
                  </tr>
                  <tr>
                     <td>_amount</td>
                     <td>Amount deposited (be sure to use the grains format specific of the collateral token you are using (e.g. if you wanted to deposit 1 USDC, you would enter 1000000 since the USDC token contract has 6 decimal places)</td>
                  </tr>
               </tbody>
            </table>
            <p>An example Python implementation is displayed on the right, but feel free to utilize whichever language, tooling, and abstractions you see fit.</p>
            <h2 id="connecting-to-the-websocket-api">Connecting to the Websocket API</h2>
            <blockquote>
               <p>Sample API URL connection generation (Python)</p>
            </blockquote>
            <pre class="highlight python"><code><span class="hljs-keyword">from</span> web3 <span class="hljs-keyword">import</span> Web3
<span class="hljs-keyword">from</span> eth_account.messages <span class="hljs-keyword">import</span> encode_defunct
<span class="hljs-keyword">from</span> eth_abi <span class="hljs-keyword">import</span> encode_abi
<span class="hljs-keyword">import</span> time

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_url</span>(<span class="hljs-params">self</span>) -&gt; str:</span>
    <span class="hljs-comment"># A Web3 instance</span>
    w3 = Web3(Web3.HTTPProvider(<span class="hljs-string">&quot;https://kovan.infura.io/v3/&lt;your_api_key&gt;&quot;</span>))
    
    <span class="hljs-comment"># Initialize a Web3 account from a private key</span>
    web3_account = self.w3.eth.account.from_key(<span class="hljs-string">&quot;&lt;private_key&gt;&quot;</span>)

    <span class="hljs-comment"># Retrieve current UNIX time in nanoseconds to derive a unique, monotonically-increasing nonce</span>
    nonce = time.time_ns()

    <span class="hljs-comment"># keccak256(abi.encode([&#x27;bytes32&#x27;, &#x27;uint256&#x27;], [bytes_encoded(&#x27;DerivaDEX API&#x27;), nonce]))</span>
    connect_message = w3.keccak(
        encode_abi([<span class="hljs-string">&quot;bytes32&quot;</span>, <span class="hljs-string">&quot;uint256&quot;</span>], [<span class="hljs-string">&quot;DerivaDEX API&quot;</span>.encode(<span class="hljs-string">&quot;utf8&quot;</span>), nonce])
    )

    <span class="hljs-comment"># Obtain signable message</span>
    encoded_message = encode_defunct(text=connect_message.<span class="hljs-built_in">hex</span>())

    <span class="hljs-comment"># Obtain signature</span>
    signature = web3_account.sign_message(encoded_message)

    <span class="hljs-comment"># Construct WS connection url with format</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;wss://alpha.derivadex.io/trader/v1?nonce=<span class="hljs-subst">{nonce}</span>&amp;signature=<span class="hljs-subst">{signature.signature.<span class="hljs-built_in">hex</span>()}</span>&quot;</span></code></pre>
            <p>Addresses used to connect to the websocket API must <em>already</em> have funds deposited. If you haven&#39;t, <a href="#Making-a-deposit">do that first</a>.</p>
            <p>The steps to connect are:</p>
            <ol>
               <li>Generate a numeric value (<code>nonce</code>) that is greater than the last value used for this address. Typically, <a href="https://en.wikipedia.org/wiki/Unix_time">Unix time</a> (either milliseconds or nanoseconds) is used, but users may opt to maintain their own sequence counter. Requests with a nonce that are less than or equal to the previous value will be rejected.</li>
               <li><code>Keccak-256</code> hash the following ABI-encoded values with the specified types:<ul>
                     <li>&quot;DerivaDEX API&quot; encoded as bytes (<code>bytes32</code>) </li>
                     <li><code>nonce</code> (<code>uint256</code>)</li>
                  </ul>
               </li>
               <li>Generate a <code>signature</code> of the hash using eth_sign or equivalent signer.</li>
               <li>Connect to the websocket with the url: <code>wss://api.derivadex.com?nonce=[nonce]&amp;signature=[signature]</code></li>
            </ol>
            <p>An example Python implementation is displayed on the right, but feel free to utilize whichever language, tooling, and abstractions you see fit.</p>
            <h1 id="commands">Commands</h1>
            <p>The websocket API offers commands for placing and canceling orders, as well as withdrawals. Since commands modify system state, these requests must include an <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md">EIP-712 signature</a>. Examples are included in the <a href="samples.md">sample code</a>.</p>
            <h2 id="place-order">Place order</h2>
            <h3 id="request">Request</h3>
            <blockquote>
               <p>Request format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;request&quot;</span>: {
        <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Order&quot;</span>,
        <span class="hljs-attr">&quot;c&quot;</span>: {
            <span class="hljs-attr">&quot;traderAddress&quot;</span>: <span class="hljs-string">&quot;0x603699848c84529987E14Ba32C8a66DEF67E9eCE&quot;</span>,
            <span class="hljs-attr">&quot;symbol&quot;</span>: <span class="hljs-string">&quot;ETHPERP&quot;</span>,
            <span class="hljs-attr">&quot;strategy&quot;</span>: <span class="hljs-string">&quot;main&quot;</span>,
            <span class="hljs-attr">&quot;side&quot;</span>: <span class="hljs-string">&quot;Bid&quot;</span>,
            <span class="hljs-attr">&quot;orderType&quot;</span>: <span class="hljs-string">&quot;Limit&quot;</span>,
            <span class="hljs-attr">&quot;requestId&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span>,
            <span class="hljs-attr">&quot;amount&quot;</span>: <span class="hljs-number">10</span>,
            <span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-number">497.97</span>,
            <span class="hljs-attr">&quot;stopPrice&quot;</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">&quot;signature&quot;</span>: <span class="hljs-string">&quot;0x&quot;</span>
        }
    }
}</code></pre>
            <p>You can place new orders by specifying specific attributes in the <code>Order</code> command&#39;s request payload. These requests are subject to a set of validations.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>address_s</td>
                     <td>traderAddress</td>
                     <td>Trader&#39;s Ethereum address (same as the one that facilitated the deposit)</td>
                  </tr>
                  <tr>
                     <td>string</td>
                     <td>symbol</td>
                     <td>Name of the market to trade. Currently, this is limited to &#39;ETHPERP&#39;, but new symbols are coming soon!</td>
                  </tr>
                  <tr>
                     <td>string</td>
                     <td>strategy</td>
                     <td>Name of the cross-margined strategy this trade belongs to. Currently, this is limited to the default <code>main</code> strategy, but support for multiple strategies is coming soon!</td>
                  </tr>
                  <tr>
                     <td>string</td>
                     <td>side</td>
                     <td>Side of trade, either <code>Bid</code> (buy/long) or an <code>Ask</code> (sell/short)</td>
                  </tr>
                  <tr>
                     <td>string</td>
                     <td>orderType</td>
                     <td>Order type, either <code>Limit</code> or <code>Market</code>. Other order types coming soon!</td>
                  </tr>
                  <tr>
                     <td>bytes32_s</td>
                     <td>requestId</td>
                     <td>An incrementing numeric identifier for this request that is unique per user for all time</td>
                  </tr>
                  <tr>
                     <td>decimal</td>
                     <td>amount</td>
                     <td>The order amount/size requested</td>
                  </tr>
                  <tr>
                     <td>decimal</td>
                     <td>price</td>
                     <td>The order price</td>
                  </tr>
                  <tr>
                     <td>decimal</td>
                     <td>stopPrice</td>
                     <td>Currently, always 0 as stops are not implemented.</td>
                  </tr>
                  <tr>
                     <td>bytes_s</td>
                     <td>signature</td>
                     <td>EIP-712 signature of the order placement intent</td>
                  </tr>
               </tbody>
            </table>
            <h3 id="response">Response</h3>
            <blockquote>
               <p>Receipt (success) format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;receipt&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Received&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;requestId&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;</span>,
      <span class="hljs-attr">&quot;requestIndex&quot;</span>: <span class="hljs-string">&quot;0x5&quot;</span>,
      <span class="hljs-attr">&quot;enclaveSignature&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>
    }
  }
}</code></pre>
            <p>A place order <code>command</code> returns a response receipt, which confirms that an Operator has received the request and has sequenced it for processing. The receipt <code>type</code> will be either <code>Received</code> or <code>Error</code>.</p>
            <p>A successful <code>command</code> returns a <code>Received</code> receipt from the Operator. DerivaDEX Operators execute code within a trusted execution environment. The enclaveSignature affirms that this environment has the security guarantees associated with Intel SGX TEEs.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>bytes32_s</td>
                     <td>requestId</td>
                     <td>The requestId supplied in the initial request - can be used to correlate requests with receipts</td>
                  </tr>
                  <tr>
                     <td>??</td>
                     <td>requestIndex</td>
                     <td>A ticket number which guarantees fair sequencing</td>
                  </tr>
                  <tr>
                     <td>bytes_s</td>
                     <td>enclaveSignature</td>
                     <td>An Operator&#39;s signature which proves secure handling of the request</td>
                  </tr>
               </tbody>
            </table>
            <blockquote>
               <p>Receipt (error) format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;receipt&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Error&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;Nonces cannot go backwards&quot;</span>
    }
  }
}</code></pre>
            <p>An erroneous command returns an <code>Error</code> receipt from the Operator.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>string</td>
                     <td>msg</td>
                     <td>Error message</td>
                  </tr>
               </tbody>
            </table>
            <h2 id="cancel-order">Cancel order</h2>
            <blockquote>
               <p>Request format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;request&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;CancelOrder&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;symbol&quot;</span>: <span class="hljs-string">&quot;ETHPERP&quot;</span>,
      <span class="hljs-attr">&quot;orderHash&quot;</span>: <span class="hljs-string">&quot;0xa2e47f2d462c4368fdae25028447c78118ba349141d0ba945c6f100dfd149029&quot;</span>,
      <span class="hljs-attr">&quot;requestId&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;</span>,
      <span class="hljs-attr">&quot;signature&quot;</span>: <span class="hljs-string">&quot;0x89fb49d2d125adfef56328ee7367d23d1642d2fb6cfdf8843fa94ae7eac9ab23&quot;</span>
    }
  }
}</code></pre>
            <p>You can cancel existing orders by specifying specific attributes in the <code>CancelOrder</code> command&#39;s request payload.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>string</td>
                     <td>symbol</td>
                     <td>Currently always &#39;ETHPERP&#39;. New symbols coming soon!</td>
                  </tr>
                  <tr>
                     <td>bytes32_s</td>
                     <td>orderHash</td>
                     <td>The hash of the order being canceled.</td>
                  </tr>
                  <tr>
                     <td>bytes32_s</td>
                     <td>requestId</td>
                     <td>An incrementing numeric identifier for this request that is unique per user for all time</td>
                  </tr>
                  <tr>
                     <td>bytes_s</td>
                     <td>signature</td>
                     <td>EIP-712 signature</td>
                  </tr>
               </tbody>
            </table>
            <p>As described in the <code>Signatures &amp; hashing</code> section, the <code>orderHash</code> is something that you construct client-side prior to submitting the order to the exchange. In this regard, you have the <code>orderHash</code> for each order you submit irrespective of acknowledgement from the exchange. You can determine which ones have actually been received by the exchange by filtering all the ones you have sent by using the <code>requestId</code> field in the successful/received responses from the place order <code>command</code>. As an alternate/additional reference, the <code>OrdersUpdate</code> <code>subscription</code> (see below for further information) includes the <code>orderHash</code> field for any open orders you have.</p>
            <h3 id="response-1">Response</h3>
            <blockquote>
               <p>Receipt (success) format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;receipt&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Received&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;requestId&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;</span>,
      <span class="hljs-attr">&quot;requestIndex&quot;</span>: <span class="hljs-string">&quot;0x5&quot;</span>,
      <span class="hljs-attr">&quot;enclaveSignature&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>
    }
  }
}</code></pre>
            <p>A cancel order <code>command</code> returns a response receipt, which confirms that an Operator has received the request and has sequenced it for processing. The receipt <code>type</code> will be either <code>Received</code> or <code>Error</code>.</p>
            <p>A successful <code>command</code> returns a <code>Received</code> receipt from the Operator. DerivaDEX Operators execute code within a trusted execution environment. The enclaveSignature affirms that this environment has the security guarantees associated with Intel SGX TEEs.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>bytes32_s</td>
                     <td>requestId</td>
                     <td>The requestId supplied in the initial request - can be used to correlate requests with receipts</td>
                  </tr>
                  <tr>
                     <td>??</td>
                     <td>requestIndex</td>
                     <td>A ticket number which guarantees fair sequencing</td>
                  </tr>
                  <tr>
                     <td>bytes_s</td>
                     <td>enclaveSignature</td>
                     <td>An Operator&#39;s signature which proves secure handling of the request</td>
                  </tr>
               </tbody>
            </table>
            <blockquote>
               <p>Receipt (error) format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;receipt&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Error&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;Nonces cannot go backwards&quot;</span>
    }
  }
}</code></pre>
            <p>An erroneous command returns an <code>Error</code> receipt from the Operator.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>string</td>
                     <td>msg</td>
                     <td>Error message</td>
                  </tr>
               </tbody>
            </table>
            <h2 id="withdraw">Withdraw</h2>
            <blockquote>
               <p>Request format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;request&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Withdraw&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;traderAddress&quot;</span>: <span class="hljs-string">&quot;0x603699848c84529987E14Ba32C8a66DEF67E9eCE&quot;</span>,
      <span class="hljs-attr">&quot;strategyId&quot;</span>: <span class="hljs-string">&quot;main&quot;</span>,
      <span class="hljs-attr">&quot;currency&quot;</span>: <span class="hljs-string">&quot;0x41082c820342539de44c1b404fead3b4b39e15d6&quot;</span>,
      <span class="hljs-attr">&quot;amount&quot;</span>: <span class="hljs-number">440.32</span>,
      <span class="hljs-attr">&quot;requestId&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;</span>,
      <span class="hljs-attr">&quot;signature&quot;</span>: <span class="hljs-string">&quot;0x89fb49d2d125adfef56328ee7367d23d1642d2fb6cfdf8843fa94ae7eac9ab23&quot;</span>
    }
  }
}</code></pre>
            <p>You can signal withdrawal intents to the Operators by specifying specific attributes in the <code>Withdraw</code> command&#39;s request payload. Withdrawal is a 2-step process: submitting a withdrawal intent, and performing a smart contract withdrawal. Once a withdrawal intent is initiated, you won&#39;t be able to trade with the collateral you are attempting to withdraw. You will only be able to formally initiate a smart contract withdrawal/token transfer once the epoch in which you signal your withdrawal desire has concluded. </p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>address_s</td>
                     <td>traderAddress</td>
                     <td>Trader&#39;s Ethereum address (same as the one that facilitated the deposit)</td>
                  </tr>
                  <tr>
                     <td>string</td>
                     <td>strategyId</td>
                     <td>Name of the cross-margined strategy this withdrawal belongs to. Currently, this is limited to the default <code>main</code> strategy, but support for multiple strategies is coming soon!</td>
                  </tr>
                  <tr>
                     <td>address_s</td>
                     <td>currency</td>
                     <td>ERC-20 token address being withdrawn</td>
                  </tr>
                  <tr>
                     <td>decimal</td>
                     <td>amount</td>
                     <td>Amount withdrawn (be sure to use the grains format specific to the collateral token being used (e.g. if you wanted to withdraw 1 USDC, you would enter 1000000 since the USDC token contract has 6 decimal places)</td>
                  </tr>
                  <tr>
                     <td>bytes32_s</td>
                     <td>requestId</td>
                     <td>An incrementing numeric identifier for this request that is unique per user for all time</td>
                  </tr>
                  <tr>
                     <td>bytes_s</td>
                     <td>signature</td>
                     <td>EIP-712 signature</td>
                  </tr>
               </tbody>
            </table>
            <h3 id="response-2">Response</h3>
            <blockquote>
               <p>Receipt (success) format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;receipt&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Received&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;requestId&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;</span>,
      <span class="hljs-attr">&quot;requestIndex&quot;</span>: <span class="hljs-string">&quot;0x5&quot;</span>,
      <span class="hljs-attr">&quot;enclaveSignature&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>
    }
  }
}</code></pre>
            <p>A withdraw <code>command</code> returns a response receipt, which confirms that an Operator has received the request and has sequenced it for processing. The receipt <code>type</code> will be either <code>Received</code> or <code>Error</code>.</p>
            <p>A successful <code>command</code> returns a <code>Received</code> receipt from the Operator. DerivaDEX Operators execute code within a trusted execution environment. The enclaveSignature affirms that this environment has the security guarantees associated with Intel SGX TEEs.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>bytes32_s</td>
                     <td>requestId</td>
                     <td>The requestId supplied in the initial request - can be used to correlate requests with receipts</td>
                  </tr>
                  <tr>
                     <td>??</td>
                     <td>requestIndex</td>
                     <td>A ticket number which guarantees fair sequencing</td>
                  </tr>
                  <tr>
                     <td>bytes_s</td>
                     <td>enclaveSignature</td>
                     <td>An Operator&#39;s signature which proves secure handling of the request</td>
                  </tr>
               </tbody>
            </table>
            <blockquote>
               <p>Receipt (error) format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;receipt&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Error&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;Nonces cannot go backwards&quot;</span>
    }
  }
}</code></pre>
            <p>An erroneous command returns an <code>Error</code> receipt from the Operator.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>string</td>
                     <td>msg</td>
                     <td>Error message</td>
                  </tr>
               </tbody>
            </table>
            <h1 id="subscriptions">Subscriptions</h1>
            <p>You can subscribe to two different kinds of feeds corresponding to a specific trader&#39;s account or market data with <code>SubscribeAccount</code> or <code>SubscribeMarket</code> requests, respectively.</p>
            <h2 id="account">Account</h2>
            <h3 id="request-1">Request</h3>
            <blockquote>
               <p>Request format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;request&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;SubscribeAccount&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;trader&quot;</span>: <span class="hljs-string">&quot;0x603699848c84529987E14Ba32C8a66DEF67E9eCE&quot;</span>,
      <span class="hljs-attr">&quot;strategies&quot;</span>: [<span class="hljs-string">&quot;main&quot;</span>],
      <span class="hljs-attr">&quot;events&quot;</span>: [<span class="hljs-string">&quot;StrategyUpdate&quot;</span>, <span class="hljs-string">&quot;OrdersUpdate&quot;</span>, <span class="hljs-string">&quot;PositionUpdate&quot;</span>]
    }
  }
}</code></pre>
            <p>You can subscribe to data feeds corresponding to events for a particular trader&#39;s Ethereum address. The possible account events you can subscribe to are <code>StrategyUpdate</code>, <code>OrdersUpdate</code>, and <code>PositionUpdate</code>.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>address_s</td>
                     <td>trader</td>
                     <td>Trader&#39;s Ethereum address (same as the one that facilitated the deposit)</td>
                  </tr>
                  <tr>
                     <td>string[]</td>
                     <td>strategies</td>
                     <td>Strategies being subscribed to. Currently, the only supported strategy is <code>main</code>, but support for multiple strategies is coming soon!</td>
                  </tr>
                  <tr>
                     <td>string[]</td>
                     <td>events</td>
                     <td>Events being subscribed to. This can be one or more of <code>StrategyUpdate</code>, <code>OrdersUpdate</code>, and <code>PositionUpdate</code></td>
                  </tr>
               </tbody>
            </table>
            <h3 id="response-3">Response</h3>
            <blockquote>
               <p>Receipt (success) format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;receipt&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Subscribed&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;Subscribed to [StrategyUpdate | OrdersUpdate | PositionUpdate] for ETHPERP&quot;</span>
    }
  }
}</code></pre>
            <p>Each <code>subscription</code> returns a receipt, which confirms that an Operator has received the <code>subscription</code> request. The receipt <code>type</code> will be either <code>Subscribed</code> or <code>Error</code>.</p>
            <p>A successful <code>subscription</code> returns a <code>Subscribed</code> receipt from the Operator.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>string</td>
                     <td>msg</td>
                     <td>Success message</td>
                  </tr>
               </tbody>
            </table>
            <blockquote>
               <p>Receipt (error) format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;receipt&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Error&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;Invalid subscription&quot;</span>
    }
  }
}</code></pre>
            <p>An erroneous <code>subscription</code> returns an <code>Error</code> receipt from the Operator.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>string</td>
                     <td>msg</td>
                     <td>Error message</td>
                  </tr>
               </tbody>
            </table>
            <p>Each of the market <code>subscription</code> events will be discussed below individually. </p>
            <p>Each subscription event will be discussed below individually. </p>
            <h2 id="strategy-update-account">Strategy update (account)</h2>
            <blockquote>
               <p>Partial response (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;StrategyUpdate&quot;</span>,
    <span class="hljs-attr">&quot;e&quot;</span>: <span class="hljs-string">&quot;Partial&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: [{
        <span class="hljs-attr">&quot;trader&quot;</span>: <span class="hljs-string">&quot;0xe36ea790bc9d7ab70c55260c66d52b1eca985f84&quot;</span>,
        <span class="hljs-attr">&quot;strategy&quot;</span>: <span class="hljs-string">&quot;main&quot;</span>,
        <span class="hljs-attr">&quot;maxLeverage&quot;</span>: <span class="hljs-string">&quot;20&quot;</span>,
        <span class="hljs-attr">&quot;freeCollateral&quot;</span>: {
          <span class="hljs-attr">&quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;</span>: <span class="hljs-string">&quot;1000&quot;</span>
        },
        <span class="hljs-attr">&quot;frozenCollateral&quot;</span>: {
          <span class="hljs-attr">&quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>
        },
        <span class="hljs-attr">&quot;createdAt&quot;</span>: <span class="hljs-string">&quot;2021-03-23T20:03:45.850Z&quot;</span>
    }]
}</code></pre>
            <blockquote>
               <p>Update response (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;StrategyUpdate&quot;</span>,
    <span class="hljs-attr">&quot;e&quot;</span>: <span class="hljs-string">&quot;Update&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: [{
        <span class="hljs-attr">&quot;trader&quot;</span>: <span class="hljs-string">&quot;0xe36ea790bc9d7ab70c55260c66d52b1eca985f84&quot;</span>,
        <span class="hljs-attr">&quot;strategy&quot;</span>: <span class="hljs-string">&quot;main&quot;</span>,
        <span class="hljs-attr">&quot;maxLeverage&quot;</span>: <span class="hljs-string">&quot;20&quot;</span>,
        <span class="hljs-attr">&quot;freeCollateral&quot;</span>: {
          <span class="hljs-attr">&quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;</span>: <span class="hljs-string">&quot;2000&quot;</span>
        },
        <span class="hljs-attr">&quot;frozenCollateral&quot;</span>: {
          <span class="hljs-attr">&quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>
        },
        <span class="hljs-attr">&quot;frozen&quot;</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">&quot;createdAt&quot;</span>: <span class="hljs-string">&quot;2021-03-23T20:03:45.850Z&quot;</span>
    }]
}</code></pre>
            <p>You can subscribe to updates to their strategy with the <code>StrategyUpdate</code> event. A strategy is a cross-margined account in which you can deposit/withdraw collateral and make trades. Strategies are siloed off from one another. Any updates to the free or frozen collaterals you have (whether it&#39;s from deposits, withdrawals, or realized PNL) will be registered in this feed.</p>
            <p>Upon subscription, you will receive a <code>Partial</code> back, containing a snapshot of your strategy at that moment in time. From then on, you will receive streaming <code>Update</code> messages as appropriate. </p>
            <p>For the response, an array of updates per strategy you have subscribed to is emitted, with each update defined as follows:</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>address_s</td>
                     <td>trader</td>
                     <td>Trader&#39;s Ethereum address (same as the one requested)</td>
                  </tr>
                  <tr>
                     <td>string_s</td>
                     <td>strategy</td>
                     <td>Strategy being subscribed to. Currently, the only supported strategy is <code>main</code>, but support for multiple strategies is coming soon!</td>
                  </tr>
                  <tr>
                     <td>int_s</td>
                     <td>maxLeverage</td>
                     <td>Maximum leverage for strategy, which impacts the maintenance margin ratio associated to any given trader</td>
                  </tr>
                  <tr>
                     <td>&lt;address_s, decimal_s&gt;</td>
                     <td>freeCollateral</td>
                     <td>Collateral (on a per token basis) available for trading (not to be confused with the <code>Free Collateral</code> displayed on the UI, which is the collateral available to a trader wishing to signal a withdraw intent)</td>
                  </tr>
                  <tr>
                     <td>&lt;address_s, decimal_s&gt;</td>
                     <td>frozenCollateral</td>
                     <td>Collateral (on a per token basis) available for a smart contract withdrawal, but not for trading, since the Operators have received the withdraw intent)</td>
                  </tr>
                  <tr>
                     <td>bool</td>
                     <td>frozen</td>
                     <td>Whether the account and its collateral is frozen or not</td>
                  </tr>
               </tbody>
            </table>
            <h2 id="orders-update-account">Orders update (account)</h2>
            <blockquote>
               <p>Partial response (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;OrdersUpdate&quot;</span>,
    <span class="hljs-attr">&quot;e&quot;</span>: <span class="hljs-string">&quot;Partial&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: [{
        <span class="hljs-attr">&quot;orderHash&quot;</span>: <span class="hljs-string">&quot;0x946e4bedf2dd87e5380f32a18d1af19adb4d7ecec3a8a346cb641adc5201e53e&quot;</span>,
        <span class="hljs-attr">&quot;traderAddress&quot;</span>: <span class="hljs-string">&quot;0xe36ea790bc9d7ab70c55260c66d52b1eca985f84&quot;</span>,
        <span class="hljs-attr">&quot;symbol&quot;</span>: <span class="hljs-string">&quot;ETHPERP&quot;</span>,
        <span class="hljs-attr">&quot;side&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,
        <span class="hljs-attr">&quot;orderType&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,
        <span class="hljs-attr">&quot;requestId&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span>,
        <span class="hljs-attr">&quot;amount&quot;</span>: <span class="hljs-string">&quot;10.000000000000000000&quot;</span>,
        <span class="hljs-attr">&quot;remainingAmount&quot;</span>: <span class="hljs-string">&quot;10.000000000000000000&quot;</span>,
        <span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-string">&quot;521.800000000000000000&quot;</span>,
        <span class="hljs-attr">&quot;stopPrice&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,
        <span class="hljs-attr">&quot;signature&quot;</span>: <span class="hljs-string">&quot;0x&quot;</span>,
        <span class="hljs-attr">&quot;createdAt&quot;</span>: <span class="hljs-string">&quot;2021-03-24T23:25:41.467Z&quot;</span>
    }]
}</code></pre>
            <blockquote>
               <p>Update response (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;OrdersUpdate&quot;</span>,
    <span class="hljs-attr">&quot;e&quot;</span>: <span class="hljs-string">&quot;Update&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: [{
        <span class="hljs-attr">&quot;orderHash&quot;</span>: <span class="hljs-string">&quot;0x946e4bedf2dd87e5380f32a18d1af19adb4d7ecec3a8a346cb641adc5201e53e&quot;</span>,
        <span class="hljs-attr">&quot;traderAddress&quot;</span>: <span class="hljs-string">&quot;0xe36ea790bc9d7ab70c55260c66d52b1eca985f84&quot;</span>,
        <span class="hljs-attr">&quot;symbol&quot;</span>: <span class="hljs-string">&quot;ETHPERP&quot;</span>,
        <span class="hljs-attr">&quot;side&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,
        <span class="hljs-attr">&quot;orderType&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,
        <span class="hljs-attr">&quot;requestId&quot;</span>: <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span>,
        <span class="hljs-attr">&quot;amount&quot;</span>: <span class="hljs-string">&quot;10&quot;</span>,
        <span class="hljs-attr">&quot;remainingAmount&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,
        <span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-string">&quot;521.8&quot;</span>,
        <span class="hljs-attr">&quot;stopPrice&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,
        <span class="hljs-attr">&quot;signature&quot;</span>: <span class="hljs-string">&quot;0x&quot;</span>,
        <span class="hljs-attr">&quot;createdAt&quot;</span>: <span class="hljs-string">&quot;2021-03-24T23:25:41.467Z&quot;</span>
    }]
}</code></pre>
            <p>You can subscribe to updates to your open orders with the <code>OrdersUpdate</code> event. </p>
            <p>Upon subscription, you will receive a <code>Partial</code> back, containing a snapshot of all of your open orders at that moment in time. From then on, you will receive streaming/incremental <code>Update</code> messages with any changes to these orders (due to posting new orders, canceling existing orders, or orders that have been matched in partial or in full).</p>
            <p>For the response, an array of updates per order is emitted, with each update defined as follows:</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>bytes32_s</td>
                     <td>orderHash</td>
                     <td>Hash of the order that has changed or is new</td>
                  </tr>
                  <tr>
                     <td>address_s</td>
                     <td>traderAddress</td>
                     <td>Trader&#39;s Ethereum address associated with this order</td>
                  </tr>
                  <tr>
                     <td>string</td>
                     <td>symbol</td>
                     <td>Name of the market this order belongs to. Currently, this is limited to &#39;ETHPERP&#39;, but new symbols are coming soon!</td>
                  </tr>
                  <tr>
                     <td>string</td>
                     <td>strategy</td>
                     <td>Name of the cross-margined strategy this order belongs to. Currently, this is limited to the default <code>main</code> strategy, but support for multiple strategies is coming soon!</td>
                  </tr>
                  <tr>
                     <td>int_s</td>
                     <td>side</td>
                     <td>Side of order, either <code>0</code> (<code>Bid</code>) or an <code>1</code> (<code>Ask</code>)</td>
                  </tr>
                  <tr>
                     <td>int_s</td>
                     <td>orderType</td>
                     <td>Order type, either <code>0</code> (<code>Limit</code>) or <code>0</code> (<code>Market</code>). Other order types coming soon!</td>
                  </tr>
                  <tr>
                     <td>bytes32_s</td>
                     <td>requestId</td>
                     <td>Numeric identifier for the order. To clarify, this is NOT an identifier relating to this particular subscription/response, but rather the <code>requestId</code> field associated with this order at the time of placement.</td>
                  </tr>
                  <tr>
                     <td>decimal_s</td>
                     <td>amount</td>
                     <td>The original order amount/size requested</td>
                  </tr>
                  <tr>
                     <td>decimal_s</td>
                     <td>remainingAmount</td>
                     <td>The order amount/size remaining on the order book</td>
                  </tr>
                  <tr>
                     <td>decimal_s</td>
                     <td>price</td>
                     <td>The order price</td>
                  </tr>
                  <tr>
                     <td>decimal_s</td>
                     <td>stopPrice</td>
                     <td>Currently, always 0 as stops are not implemented.</td>
                  </tr>
                  <tr>
                     <td>bytes_s</td>
                     <td>signature</td>
                     <td>EIP-712 signature</td>
                  </tr>
                  <tr>
                     <td>timestamp_s</td>
                     <td>createdAt</td>
                     <td>Timestamp when order was initially created</td>
                  </tr>
               </tbody>
            </table>
            <h2 id="positions-update-account">Positions update (account)</h2>
            <p>TBD</p>
            <h2 id="market">Market</h2>
            <h3 id="request-2">Request</h3>
            <blockquote>
               <p>Request format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;request&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;SubscribeMarket&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;symbols&quot;</span>: [<span class="hljs-string">&quot;ETHPERP&quot;</span>],
      <span class="hljs-attr">&quot;events&quot;</span>: [<span class="hljs-string">&quot;OrderBookUpdate&quot;</span>, <span class="hljs-string">&quot;MarkPriceUpdate&quot;</span>]
    }
  }
}</code></pre>
            <p>You can subscribe to data feeds corresponding to events for the broader market. The possible market events you can subscribe to at this time are <code>OrderBookUpdate</code> and <code>MarkPriceUpdate</code>. </p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>string[]</td>
                     <td>symbols</td>
                     <td>Symbols being subscribed to. Currently, the only supported symbol is <code>ETHPERP</code>, but support for more symbols is coming soon!</td>
                  </tr>
                  <tr>
                     <td>string[]</td>
                     <td>events</td>
                     <td>Events being subscribed to. This can be one or more of <code>OrderBookUpdate</code> and <code>MarkPriceUpdate</code></td>
                  </tr>
               </tbody>
            </table>
            <h3 id="response-4">Response</h3>
            <blockquote>
               <p>Receipt (success) format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;receipt&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Subscribed&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;Subscribed to [OrderBookUpdate | MarkPriceUpdate] for ETHPERP&quot;</span>
    }
  }
}</code></pre>
            <p>Each <code>subscription</code> returns a receipt, which confirms that an Operator has received the <code>subscription</code> request. The receipt <code>type</code> will be either <code>Subscribed</code> or <code>Error</code>.</p>
            <p>A successful <code>subscription</code> returns a <code>Subscribed</code> receipt from the Operator.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>string</td>
                     <td>msg</td>
                     <td>Success message</td>
                  </tr>
               </tbody>
            </table>
            <blockquote>
               <p>Receipt (error) format (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
  <span class="hljs-attr">&quot;receipt&quot;</span>: {
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;Error&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: {
      <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;Invalid subscription&quot;</span>
    }
  }
}</code></pre>
            <p>An erroneous <code>subscription</code> returns an <code>Error</code> receipt from the Operator.</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>string</td>
                     <td>msg</td>
                     <td>Error message</td>
                  </tr>
               </tbody>
            </table>
            <p>Each of the market <code>subscription</code> events will be discussed below individually. </p>
            <h2 id="order-book-update-market">Order book update (market)</h2>
            <blockquote>
               <p>Partial response (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;OrderBookUpdate&quot;</span>,
    <span class="hljs-attr">&quot;e&quot;</span>: <span class="hljs-string">&quot;Partial&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: [{
        <span class="hljs-attr">&quot;bids&quot;</span>: [
            [<span class="hljs-string">&quot;516.58&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>],
            [<span class="hljs-string">&quot;511.36&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>]
        ],
        <span class="hljs-attr">&quot;asks&quot;</span>: [],
        <span class="hljs-attr">&quot;timestamp&quot;</span>: <span class="hljs-string">&quot;1616664308163&quot;</span>,
        <span class="hljs-attr">&quot;nonce&quot;</span>: <span class="hljs-string">&quot;0x1848dbc26865f118d0ea56ecf776ee68b5a9b39e0223d4e322374c087a66a201&quot;</span>,
        <span class="hljs-attr">&quot;aggregationType&quot;</span>: <span class="hljs-string">&quot;0.0001&quot;</span>
    }]
}</code></pre>
            <blockquote>
               <p>Update response (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;OrderBookUpdate&quot;</span>,
    <span class="hljs-attr">&quot;e&quot;</span>: <span class="hljs-string">&quot;Partial&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: [{
        <span class="hljs-attr">&quot;bids&quot;</span>: [
            [<span class="hljs-string">&quot;516.58&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>]
        ],
        <span class="hljs-attr">&quot;asks&quot;</span>: [
            [<span class="hljs-string">&quot;527.01&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>]
        ],
        <span class="hljs-attr">&quot;timestamp&quot;</span>: <span class="hljs-string">&quot;1616667513875&quot;</span>,
        <span class="hljs-attr">&quot;nonce&quot;</span>: <span class="hljs-string">&quot;0xc423f94e3ba40527b7bed2925cfedabf8a68388bde06f090a772b8bf3c791f5f&quot;</span>,
        <span class="hljs-attr">&quot;aggregationType&quot;</span>: <span class="hljs-string">&quot;0.0001&quot;</span>
    }]
}</code></pre>
            <p>You can subscribe to updates to an L2-order book for any given market with the <code>OrderBookUpdate</code> event. As is typically seen, an order book is a price-time FIFO priority queue market place for you to interact with. Since this is an L2-aggregation, the response will collapse any given price level to the aggregate quantity at that level irrespective of the number of participants or the individual order details that comprise that price level.</p>
            <p>Upon subscription, you will receive a <code>Partial</code> back, containing an L2-aggregate snapshot of the order book at that moment in time. From then on, you will receive streaming/incremental <code>Update</code> messages as appropriate containing only the aggregated price levels that are different (due to the placement of new orders, order cancellation, or liquidations/matches that have taken place). Updates will come in with a reference to the side of the order book and in the form of 2-item lists with the format <code>[price, new aggregate quantity]</code>. A new aggregate quantity of <code>0</code> indicates that the price level is now gone. </p>
            <p>For the response, an array of updates per order book is emitted, with each update defined as follows:</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>decimal_s[2][]</td>
                     <td>bids</td>
                     <td>The price and corresponding updated aggregate quantity for the bids</td>
                  </tr>
                  <tr>
                     <td>decimal_s[2][]</td>
                     <td>asks</td>
                     <td>The price and corresponding updated aggregate quantity for the asks</td>
                  </tr>
                  <tr>
                     <td>timestamp_i</td>
                     <td>timestamp</td>
                     <td>Timestamp of order book partial/update</td>
                  </tr>
                  <tr>
                     <td>timestamp_s_i</td>
                     <td>nonce</td>
                     <td>???</td>
                  </tr>
                  <tr>
                     <td>decimal_s</td>
                     <td>aggregationType</td>
                     <td>???</td>
                  </tr>
               </tbody>
            </table>
            <h3 id="maintaining-local-order-book">Maintaining local order book</h3>
            <p>To maintain a local order book, you can use a combination of the <code>Partial</code> snapshot and <code>Update</code> streaming messages. A sample algorithm is as follows:</p>
            <ol>
               <li>Receive a <code>Partial</code> snapshot and use that as the starting point for the order book. Keep in mind that the response outputs the aggregated quantities at each price level for both the <code>bids</code> and <code>asks</code> sides of the order book.</li>
               <li>For every <code>Update</code> streaming message, you will receive information for both sides of the order book regarding any price level that has changed. There will be no explicit indication if a level has been newly-formed, modified, or deleted. For any <code>[price, updated_aggregated_quantity]</code> you receive, update your local order book. If your local order book does not currently have an entry for this <code>price</code>, you know it is a new level and can set the quantity to <code>updated_aggregated_quantity</code>. If your local order book has the price level corresponding to <code>price</code>, adjust its quantity to <code>updated_aggregated_quantity</code> except in the scenario where <code>updated_aggregated_quantity</code> is <code>&quot;0&quot;</code>, in which case you can delete the level entirely.</li>
               <li>If your connection drops or you believe you may have missed/mishandled an update, simply refetch the <code>Partial</code> as per Step 1, and proceed from there with Step 2.</li>
            </ol>
            <h2 id="mark-price-update-market">Mark price update (market)</h2>
            <blockquote>
               <p>Partial response (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;MarkPriceUpdate&quot;</span>,
    <span class="hljs-attr">&quot;e&quot;</span>: <span class="hljs-string">&quot;Partial&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: [{
        <span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-string">&quot;508.36236848846397&quot;</span>,
        <span class="hljs-attr">&quot;symbol&quot;</span>: <span class="hljs-string">&quot;ETHPERP&quot;</span>,
        <span class="hljs-attr">&quot;createdAt&quot;</span>: <span class="hljs-string">&quot;2021-03-25T10:37:38.124Z&quot;</span>,
        <span class="hljs-attr">&quot;updatedAt&quot;</span>: <span class="hljs-string">&quot;2021-03-25T10:37:38.124Z&quot;</span>
    }]
}</code></pre>
            <blockquote>
               <p>Update response (JSON)</p>
            </blockquote>
            <pre class="highlight json"><code>{
    <span class="hljs-attr">&quot;t&quot;</span>: <span class="hljs-string">&quot;MarkPriceUpdate&quot;</span>,
    <span class="hljs-attr">&quot;e&quot;</span>: <span class="hljs-string">&quot;Update&quot;</span>,
    <span class="hljs-attr">&quot;c&quot;</span>: [{
        <span class="hljs-attr">&quot;createdAt&quot;</span>: <span class="hljs-string">&quot;2021-03-25T10:38:09.503654+00:00&quot;</span>,
        <span class="hljs-attr">&quot;updatedAt&quot;</span>: <span class="hljs-string">&quot;2021-03-25T10:38:09.503654+00:00&quot;</span>,
        <span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-string">&quot;508.95189310211146&quot;</span>,
        <span class="hljs-attr">&quot;symbol&quot;</span>: <span class="hljs-string">&quot;ETHPERP&quot;</span>
    }]
}</code></pre>
            <p>You can subscribe to updates to the mark price for any given market with the <code>MarkPriceUpdate</code> event. The mark price is an important concept on DerivaDEX as it is the price at which positions are marked when displaying unrealized PNL. Consequently, the mark price helps determine a strategy&#39;s margin fraction, thereby triggering liquidations when appropriate. The mark price is computed based on a 30s exponential moving average (often referred to as a 30s EMA) of the spread between the underlying price (a composite of several spot price feeds for the underlying asset) and the DerivaDEX order book itself. </p>
            <p>Upon subscription, you will receive a <code>Partial</code> back, containing a mark price snapshot at that moment in time. From then on, you will receive streaming/incremental <code>Update</code> messages as appropriate. </p>
            <p>For the response, an array of updates per symbol is emitted, with each update defined as follows:</p>
            <table>
               <thead>
                  <tr>
                     <th>type</th>
                     <th>field</th>
                     <th>description</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>timestamp_s</td>
                     <td>createdAt</td>
                     <td>Timestamp of original mark price entry</td>
                  </tr>
                  <tr>
                     <td>timestamp_s</td>
                     <td>updatedAt</td>
                     <td>Timestamp of mark price update</td>
                  </tr>
                  <tr>
                     <td>decimal_s</td>
                     <td>price</td>
                     <td>Mark price for the market</td>
                  </tr>
                  <tr>
                     <td>string</td>
                     <td>symbol</td>
                     <td>Market subscribed to</td>
                  </tr>
               </tbody>
            </table>
            <h1 id="validation">Validation</h1>
            <p>TBD</p>
            <h1 id="rate-limits">Rate limits</h1>
            <p>The websocket API will (eventually) use tiers to determine rate limits for each ethereum account. Rate limits restrict the number of &quot;Commands&quot; an account can place per minute.</p>
            <p>Subscriptions are not rate limited.</p>
            <h1 id="errors">Errors</h1>
            <aside class=error> This error section is stored in a separate file in `includes/_errors.md`. Slate allows you to optionally separate out your docs into many files...just save them to the `includes` folder and add them to the top of your `index.md`'s front matter. Files are included in the order listed. </aside>
            <p>The DerivaDEX API uses the following error codes:</p>
            <p>TBD</p>
         </div>
         <div class=dark-box>
            <div class=lang-selector>
               <a href=# data-language-name="json">json</a>
               <a href=# data-language-name="plaintext">plaintext</a>
               <a href=# data-language-name="python">python</a>
            </div>
         </div>
      </div>
   </body>
</html>